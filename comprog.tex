\documentclass[10pt,a4paper,titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amsthm, amssymb, amsfonts}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{float}
\usepackage[vlined,ruled]{algorithm2e}
\usepackage{color}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{listings}

\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}

\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}

\usepackage{listings}
\lstset{language=C++,
numbers=left,
showspaces=false,
showtabs=false,
breaklines=true,
showstringspaces=false,
breakatwhitespace=true,
escapeinside={(*@}{@*)},
commentstyle=\color{greencomments},
keywordstyle=\color{bluekeywords}\bfseries,
stringstyle=\color{redstrings},
basicstyle=\ttfamily
}

% Header/Footer
\geometry{includeheadfoot, margin=2.5cm}
\pagestyle{fancy}
\chead{}
\rhead{\small \textsc{Competitive Programming}}
\cfoot{\thepage}
\setlength{\headheight}{15.2pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}


% New math operators
\DeclareMathOperator{\lcm}{lcm}

% Bit operators
\newcommand*\BitAnd{\mathrel{\&}}
\newcommand*\BitOr{\mathrel{|}}
\newcommand*\ShiftLeft{\ll}
\newcommand*\ShiftRight{\gg}
\newcommand*\BitNeg{\ensuremath{\mathord{\sim}}}


% Title/Author
\title{Competitive Programming}
\author{Bjarki Ágúst Guðmundsson \and Trausti Sæmundsson \and Ingólfur Eðvarðsson}


\begin{document}

	\maketitle
	\tableofcontents
	\newpage

	\section{Code Templates}
		\subsection{C++ Header}
			\lstinputlisting{code/header.cpp}
		
		\subsection{Java Template}
			\lstinputlisting{code/template.java}

	\section{Data Structures}

		\subsection{Union-Find}
			\lstinputlisting{code/data-structures/unionfind.cpp}

		% TODO: \subsection{Segment Tree}

		\subsection{Fenwick Tree}
			A Fenwick Tree is a data structure that represents an array of $n$ numbers. It supports adjusting the $i$-th element in $O(\log n)$ time, and computing the sum of numbers in the range $i..j$ in $O(\log n)$ time. It only needs $O(n)$ space.
			\lstinputlisting{code/data-structures/fenwick_tree.cpp}

		% TODO: \subsection{Interval Tree}

		\subsection{Matrix}
			\lstinputlisting{code/data-structures/matrix.cpp}

		\subsection{Trie}
			\lstinputlisting{code/data-structures/trie.cpp}

	\section{Graphs}

		\subsection{Breadth-First Search}

			An implementation of a breadth-first search that counts the number of edges on the shortest path from the starting vertex to the ending vertex in the specified unweighted graph (which is represented with an adjacency list). Note that it assumes that the two vertices are connected. It runs in $O(|V|+|E|)$ time.
			\lstinputlisting{code/graph/bfs.cpp}

			Another implementation that doesn't assume the two vertices are connected. If there is no path from the starting vertex to the ending vertex, a \lstinline$-1$ is returned.
			\lstinputlisting{code/graph/bfs_visited.cpp}

		% TODO: \subsection{Depth-First Search}

		\subsection{Single-Source Shortest Paths}
			\subsubsection{Dijkstra's algorithm}
				An implementation of Dijkstra's algorithm that returns the length of the shortest path from the starting vertex to the ending vertex. It runs in $\Theta(|E|\log{|V|})$ time.
				\lstinputlisting{code/graph/dijkstra.cpp}

				Another implementation that returns a map, where each key of the map is a vertex reachable from the starting vertex, and the value is a tuple of the length from the starting vertex to the current vertex and the vertex that preceeds the current vertex on the shortest path from the starting vertex to the current vertex.
				\lstinputlisting{code/graph/dijkstra_path.cpp}
			\subsubsection{Bellman-Ford algorithm}
				The Bellman-Ford algorithm solves the single-source shortest paths problem in $O(|V||E|)$ time. It is slower than Dijkstra's algorithm, but it works on graphs with negative edges and has the ability to detect negative cycles, neither of which Dijkstra's algorithm can do.
				\lstinputlisting{code/graph/bellman_ford.cpp}
		\subsection{All-Pairs Shortest Paths}
			\subsubsection{Floyd-Warshall algorithm}
				The Floyd-Warshall algorithm solves the all-pairs shortest paths problem in $O(|V|^3)$ time.
				\lstinputlisting{code/graph/floyd_warshall.cpp}
		\subsection{Connected Components}
			% TODO: \subsubsection{Modified Breadth-First Search}
		\subsection{Strongly Connected Components}
			% TODO: \subsubsection{Kosaraju's algorithm}
			\subsubsection{Tarjan's algorithm}
				Tarjan's algorithm finds strongly connected components of a directed graph in $O(|V|+|E|)$ time.
				\lstinputlisting{code/graph/tarjan_scc.cpp}
		\subsection{Minimum Spanning Tree}
			\subsubsection{Kruskal's algorithm}
				\lstinputlisting{code/graph/kruskals_mst.cpp}
		\subsection{Topological Sort}
			\subsubsection{Modified Depth-First Search}
				\lstinputlisting{code/graph/tsort.cpp}
		% \subsection{Articulation Points/Bridges}
			% TODO: \subsubsection{Modified Depth-First Search}
		\subsection{Maximum Flow}
			\subsubsection{Edmonds Karp's algorithm}
				An implementation of Edmonds Karp's algorithm that runs in $O(|V||E|^2)$. It computes the maximum flow of a flow network.
				\lstinputlisting{code/graph/edmonds_karps.cpp}

	\section{Strings}
		\subsection{The $Z$ algorithm}
			Given a string $S$, $Z_i(S)$ is the longest substring of $S$ starting at $i$ that is also a prefix of $S$. The $Z$ algorithm computes these $Z$ values in $O(n)$ time, where $n = |S|$. $Z$ values can, for example, be used to find all occurrences of a pattern $P$ in a string $T$ in linear time. This is accomplished by computing $Z$ values of $S = T P$, and looking for all $i$ such that $Z_i \geq |T|$.

			\lstinputlisting{code/strings/z_algorithm.cpp}

	\section{Mathematics}

		\subsection{Fraction}
			A fraction (rational number) class. Note that numbers are stored in lowest common terms.
			\lstinputlisting{code/mathematics/fraction.cpp}

		\subsection{Binomial Coefficients}
			The binomial coefficient $\binom{n}{k} = \frac{n!}{k!(n-k)!}$ is the number of ways to choose $k$ items out of a total of $n$ items.

			\lstinputlisting{code/mathematics/nck_1.cpp}

			\lstinputlisting{code/mathematics/nck_2.cpp}

			\lstinputlisting{code/mathematics/nck_3.cpp}

		\subsection{Euclidean algorithm}
			The Euclidean algorithm computes the greatest common divisor of two integers $a$, $b$.
			\lstinputlisting{code/mathematics/gcd.cpp}

			The extended Euclidean algorithm computes the greatest common divisor $d$ of two integers $a$, $b$ and also finds two integers $x$, $y$ such that $a\times x + b\times y = d$.
			\lstinputlisting{code/mathematics/egcd.cpp}

		\subsection{Trial Division Primality Testing}
			An optimized trial division to check whether an integer is prime.
			\lstinputlisting{code/mathematics/is_prime.cpp}

		\subsection{Sieve of Eratosthenes}
			An optimized implementation of Eratosthenes' Sieve.
			\lstinputlisting{code/mathematics/prime_sieve.cpp}

		\subsection{Modular Multiplicative Inverse}
			\lstinputlisting{code/mathematics/mod_inv.cpp}

		\subsection{Modular Exponentiation}
			\lstinputlisting{code/mathematics/mod_pow.cpp}

		\subsection{Chinese Remainder Theorem}
			\lstinputlisting{code/mathematics/crt.cpp}

	\section{Other Algorithms}
		\subsection{Binary Search}
			An implementation of binary search that finds a real value $x$ on the real interval $[a,b]$ such that $|f(x) - t| < \epsilon$, where $t$ is the target value and $\epsilon$ is the maximum error allowed.
			\lstinputlisting{code/other/binary_search.cpp}

			Another implementation that finds an integer value $x$ on the integer interval $[a,b]$ such that $f(x) = t \land f(x - 1) < t$, where $t$ is the target value.
			\lstinputlisting{code/other/binary_search_low.cpp}

			Another implementation that finds an integer value $x$ on the integer interval $[a,b]$ such that $f(x) = t \land f(x + 1) > t$, where $t$ is the target value.
			\lstinputlisting{code/other/binary_search_high.cpp}

		\subsection{$n$th Permutation}
			A very fast algorithm for computing the $n$th permutation of the list $\{0,1,\ldots,k-1\}$.
			\lstinputlisting{code/other/nth_permutation.cpp}

		\subsection{Cycle-Finding}
			\subsubsection{Floyd's Cycle-Finding algorithm}
				\lstinputlisting{code/other/floyds_algorithm.cpp}

	\section{Useful Information}

		\subsection{Tips \&{} Tricks}
			\begin{itemize}
				\item How fast does our algorithm have to be? Can we use brute-force?
				\item Does order matter?
				\item Is it better to look at the problem in another way? Maybe backwards?
				\item Are there subproblems that are recomputed? Can we cache them?
				\item Do we need to remember everything we compute, or just the last few iterations of computation?
				\item Does it help to sort the data?
				\item Can we speed up lookup by using a map (tree or hash) or an array?
				\item Can we binary search the answer?
				\item Can we add vertices/edges to the graph to make the problem easier? Can we turn the graph into some other kind of a graph (perhaps a DAG, or a flow network)?
				\item Make sure integers are not overflowing.
				\item Is it better to compute the answer modulo $n$? Perhaps we can compute the answer modulo $m_1,m_2,\ldots,m_k$, where $m_1,m_2,\ldots,m_k$ are pairwise coprime integers, and find the real answer using CRT?
				\item Are there any edge cases? When $n=0, n=-1, n=1, n=2^{31}-1$ or $n=-2^{31}$? When the list is empty, or contains a single element? When the graph is empty, or contains a single vertex? When the graph contains self-loops?  When the polygon is concave or non-simple?
				\item Can we use exponentiation by squaring?
			\end{itemize}

		\subsection{Worst Time Complexity}
			\begin{tabular}{c|c|c}
				$n$ & Worst AC Algorithm & Comment \\
				\hline
				$\leq 10$ & $O(n!), O(n^6)$ & e.g. Enumerating a permutation \\
				$\leq 15$ & $O(2^n\times n^2)$ & e.g. DP TSP \\
				$\leq 20$ & $O(2^n), O(n^5)$ & e.g. DP + bitmask technique \\
				$\leq 50$ & $O(n^4)$ & e.g. DP with 3 dimensions + $O(n)$ loop, choosing  $_nC_k=4$ \\
				$\leq 10^2$ & $O(n^3)$ & e.g. Floyd Warshall's \\
				$\leq 10^3$ & $O(n^2)$ & e.g. Bubble/Selection/Insertion sort \\
				$\leq 10^5$ & $O(n\log_2{n})$ & e.g. Merge sort, building a Segment tree \\
				$\leq 10^6$ & $O(n), O(\log_2{n}), O(1)$ & Usually, contest problems have $n\leq10^6$ (e.g. to read input) \\
			\end{tabular}

		\subsection{Bit Hacks}
			\begin{itemize}
				\item \lstinline{n & -n} returns the first set bit in $n$.
				\item \lstinline{n & (n - 1)} is $0$ only if $n$ is a power of two.
				\item \lstinline{snoob(x)} returns the next integer that has the same amount of bits set as \lstinline{x}. Useful for iterating through subsets of some specified size.
					\lstinputlisting{code/tricks/snoob.cpp}
			\end{itemize}
\end{document}